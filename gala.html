<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>Gala</title>
        <style>
            * {
                box-sizing: border-box;
            }

            html,
            body {
                height: 100%;
            }

            body {
                margin: 0;
                font-family: system-ui, -apple-system, Segoe UI, Roboto,
                    Helvetica, Arial, sans-serif;
                background: #111;
                color: #eee;
            }

            .grid {
                display: block;
                height: 100vh;
                overflow-y: auto;
                scroll-snap-type: y mandatory;
                padding: 0;
                margin: 0;
            }

            .item {
                height: 100vh;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #000;
                overflow: hidden;
                scroll-snap-align: start;
            }

            .item img,
            .item video {
                display: block;
                max-width: 100vw;
                max-height: 100vh;
                width: auto;
                height: auto;
                object-fit: contain;
                background: #000;
            }

            .item a {
                display: flex;
                width: 100%;
                height: 100%;
                align-items: center;
                justify-content: center;
                color: inherit;
                text-decoration: none;
            }

            .lazy-image,
            .lazy-video {
                background: #000;
            }
        </style>
    </head>
    <body>
        <div class="grid">{items_html}</div>
        <script>
            (function () {
                // State Management
                let items = Array.from(document.querySelectorAll(".item"));
                let current = items[0] || null;
                let currentIndex = 0;
                let history = [];
                let remainingItems = [...Array(items.length).keys()];
                let viewedItems = new Set();
                const LOAD_RANGE = 2;
                const KEEP_RANGE = 5;
                let keptStart = -1;
                let keptEnd = -1;

                // Lazy Loading
                function loadImage(img) {
                    if (
                        img.classList.contains("loaded") ||
                        img.classList.contains("loading") ||
                        !img.dataset.src
                    ) {
                        return Promise.resolve();
                    }

                    return new Promise((resolve, reject) => {
                        img.classList.add("loading");

                        const tempImg = new Image();

                        tempImg.onload = () => {
                            img.src = img.dataset.src;
                            img.classList.remove("loading");
                            img.classList.add("loaded");
                            resolve();
                        };

                        tempImg.onerror = () => {
                            img.classList.remove("loading");
                            img.classList.add("error");
                            reject(new Error("Failed to load image"));
                        };

                        tempImg.src = img.dataset.src;
                    });
                }

                function loadVideo(video) {
                    if (
                        video.classList.contains("loaded") ||
                        video.classList.contains("loading") ||
                        !video.dataset.src
                    ) {
                        return Promise.resolve();
                    }

                    return new Promise((resolve, reject) => {
                        video.classList.add("loading");

                        video.onloadeddata = () => {
                            video.classList.remove("loading");
                            video.classList.add("loaded");
                            video.onloadeddata = null;
                            video.onerror = null;
                            resolve();
                        };

                        video.onerror = () => {
                            video.classList.remove("loading");
                            video.classList.add("error");
                            video.onloadeddata = null;
                            video.onerror = null;
                            reject(new Error("Failed to load video"));
                        };

                        video.src = video.dataset.src;
                        video.load();
                    });
                }

                function loadMediaAtIndex(index) {
                    if (index < 0 || index >= items.length) {
                        return;
                    }

                    const item = items[index];
                    const img = item.querySelector(".lazy-image");
                    const video = item.querySelector(".lazy-video");

                    if (img && !img.classList.contains("loaded")) {
                        loadImage(img).catch(() => {});
                    }

                    if (video && !video.classList.contains("loaded")) {
                        loadVideo(video).catch(() => {});
                    }
                }

                function unloadMediaAtIndex(index) {
                    if (index < 0 || index >= items.length) {
                        return;
                    }

                    const item = items[index];
                    const img = item.querySelector(".lazy-image");
                    const video = item.querySelector(".lazy-video");

                    if (img && img.src && img.dataset.src) {
                        img.src = "";
                        img.classList.remove("loaded", "loading");
                    }

                    if (video && video.src && video.dataset.src) {
                        video.pause();
                        video.src = "";
                        video.load();
                        video.classList.remove("loaded", "loading");
                    }
                }

                function updateMediaWindow(centerIndex) {
                    if (items.length === 0) {
                        keptStart = -1;
                        keptEnd = -1;
                        return;
                    }

                    const loadStart = Math.max(0, centerIndex - LOAD_RANGE);
                    const loadEnd = Math.min(items.length - 1, centerIndex + LOAD_RANGE);
                    const keepStart = Math.max(0, centerIndex - KEEP_RANGE);
                    const keepEnd = Math.min(items.length - 1, centerIndex + KEEP_RANGE);

                    for (let i = loadStart; i <= loadEnd; i++) {
                        loadMediaAtIndex(i);
                    }

                    if (keptStart === -1 || keptEnd === -1) {
                        keptStart = keepStart;
                        keptEnd = keepEnd;
                        return;
                    }

                    for (let i = keptStart; i <= Math.min(keepStart - 1, keptEnd); i++) {
                        unloadMediaAtIndex(i);
                    }

                    for (let i = Math.max(keepEnd + 1, keptStart); i <= keptEnd; i++) {
                        unloadMediaAtIndex(i);
                    }

                    keptStart = keepStart;
                    keptEnd = keepEnd;
                }

                function resetMediaWindow() {
                    keptStart = -1;
                    keptEnd = -1;
                }

                const observer = new IntersectionObserver(
                    (entries) => {
                        entries.forEach((entry) => {
                            const video = entry.target.querySelector("video");
                            const isVisible =
                                entry.isIntersecting &&
                                entry.intersectionRatio > 0.6 - 0.01;

                            if (isVisible) {
                                const newIndex = items.indexOf(entry.target);
                                if (newIndex !== -1) {
                                    current = entry.target;
                                    if (newIndex !== currentIndex) {
                                        currentIndex = newIndex;
                                        updateMediaWindow(currentIndex);
                                    }
                                }

                                if (
                                    video &&
                                    video.classList.contains("loaded")
                                ) {
                                    video.play().catch(() => {});
                                }
                            } else {
                                if (
                                    video &&
                                    video.classList.contains("loaded") &&
                                    !video.paused
                                ) {
                                    video.pause();
                                    video.muted = true;
                                }
                            }
                        });
                    },
                    { threshold: [0, 0.6, 1] }
                );

                items.forEach((item) => {
                    observer.observe(item);
                });

                if (items.length > 0) {
                    updateMediaWindow(0);
                }

                // Utilities
                function findClosestToCenter() {
                    const center = innerHeight / 2;
                    let closest = null;
                    let minDistance = Infinity;

                    items.forEach((item) => {
                        const rect = item.getBoundingClientRect();
                        const itemCenter = rect.top + rect.height / 2;
                        const distance = Math.abs(itemCenter - center);

                        if (distance < minDistance) {
                            minDistance = distance;
                            closest = item;
                        }
                    });

                    return closest;
                }

                function navigateToIndex(targetIndex, addToHistory = true) {
                    if (addToHistory && currentIndex !== targetIndex) {
                        history.push(currentIndex);
                    }

                    updateMediaWindow(targetIndex);

                    items[targetIndex].scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                    });
                }

                function toggleCurrentVideo() {
                    if (!current) {
                        return;
                    }

                    const video = current.querySelector("video");
                    if (!video) {
                        return;
                    }

                    if (
                        !video.classList.contains("loaded") &&
                        video.dataset.src
                    ) {
                        loadVideo(video)
                            .then(() => {
                                video.play().catch(() => {});
                            })
                            .catch(() => {});
                        return;
                    }

                    if (video.paused) {
                        video.play().catch(() => {});
                    } else {
                        video.pause();
                    }
                }

                // Basic Navigation
                function navigateToNext() {
                    if (items.length === 0) {
                        return;
                    }

                    const nextIndex = (currentIndex + 1) % items.length;
                    navigateToIndex(nextIndex);
                }

                function navigateToPrevious() {
                    if (items.length === 0) {
                        return;
                    }

                    const prevIndex =
                        (currentIndex - 1 + items.length) % items.length;
                    navigateToIndex(prevIndex);
                }

                // Path Navigation
                function getItemPath(item) {
                    const filename = item.getAttribute("data-filename");
                    if (!filename) return "";

                    const lastSlash = filename.lastIndexOf("/");
                    const lastBackslash = filename.lastIndexOf("\\");
                    const separatorIndex = Math.max(lastSlash, lastBackslash);

                    return separatorIndex > -1
                        ? filename.substring(0, separatorIndex)
                        : "";
                }

                function navigateToNextPath() {
                    if (items.length === 0) {
                        return;
                    }

                    const currentPath = getItemPath(current);

                    for (let i = currentIndex + 1; i < items.length; i++) {
                        const itemPath = getItemPath(items[i]);
                        if (itemPath !== currentPath) {
                            navigateToIndex(i);
                            return;
                        }
                    }

                    for (let i = 0; i < currentIndex; i++) {
                        const itemPath = getItemPath(items[i]);
                        if (itemPath !== currentPath) {
                            navigateToIndex(i);
                            return;
                        }
                    }
                }

                function navigateToPreviousPath() {
                    if (items.length === 0) {
                        return;
                    }

                    const currentPath = getItemPath(current);

                    for (let i = currentIndex - 1; i >= 0; i--) {
                        const itemPath = getItemPath(items[i]);
                        if (itemPath !== currentPath) {
                            let firstOfPath = i;
                            for (let j = i - 1; j >= 0; j--) {
                                if (getItemPath(items[j]) === itemPath) {
                                    firstOfPath = j;
                                } else {
                                    break;
                                }
                            }
                            navigateToIndex(firstOfPath);
                            return;
                        }
                    }

                    for (let i = items.length - 1; i > currentIndex; i--) {
                        const itemPath = getItemPath(items[i]);
                        if (itemPath !== currentPath) {
                            let firstOfPath = i;
                            for (let j = i - 1; j > currentIndex; j--) {
                                if (getItemPath(items[j]) === itemPath) {
                                    firstOfPath = j;
                                } else {
                                    break;
                                }
                            }
                            navigateToIndex(firstOfPath);
                            return;
                        }
                    }
                }

                function navigateToFirstInPath() {
                    if (items.length === 0) {
                        return;
                    }

                    const currentPath = getItemPath(current);

                    for (let i = 0; i < items.length; i++) {
                        const itemPath = getItemPath(items[i]);
                        if (itemPath === currentPath) {
                            navigateToIndex(i);
                            return;
                        }
                    }
                }

                function navigateToLastInPath() {
                    if (items.length === 0) {
                        return;
                    }

                    const currentPath = getItemPath(current);

                    for (let i = items.length - 1; i >= 0; i--) {
                        const itemPath = getItemPath(items[i]);
                        if (itemPath === currentPath) {
                            navigateToIndex(i);
                            return;
                        }
                    }
                }

                // Random Navigation
                function navigateToRandom() {
                    if (items.length === 0) {
                        return;
                    }

                    if (remainingItems.length === 0) {
                        remainingItems = [...Array(items.length).keys()];
                        viewedItems.clear();
                    }

                    viewedItems.add(currentIndex);

                    const currentInRemaining =
                        remainingItems.indexOf(currentIndex);
                    if (currentInRemaining !== -1) {
                        remainingItems.splice(currentInRemaining, 1);
                    }

                    if (remainingItems.length > 0) {
                        const randomIndex = Math.floor(
                            Math.random() * remainingItems.length
                        );
                        const targetIndex = remainingItems[randomIndex];
                        navigateToIndex(targetIndex);
                    }
                }

                function navigateBackward() {
                    if (history.length === 0) {
                        return;
                    }

                    const previousIndex = history.pop();
                    navigateToIndex(previousIndex, false);
                }

                // Deletion
                async function deleteCurrent() {
                    if (!current) {
                        return;
                    }

                    const filename = current.getAttribute("data-filename");
                    if (!filename) {
                        return;
                    }

                    try {
                        const response = await fetch(
                            "/api/delete?name=" + encodeURIComponent(filename),
                            { method: "DELETE" }
                        );

                        const data = await response.json().catch(() => ({}));

                        if (!response.ok || !data.ok) {
                            const errorMessage = data.error
                                ? ": " + data.error
                                : "";
                            alert("Delete failed" + errorMessage);
                            return;
                        }

                        const video = current.querySelector("video");
                        if (video) {
                            try {
                                video.pause();
                                video.src = "";
                            } catch (e) {}
                        }

                        observer.unobserve(current);
                        current.remove();

                        const removedIndex = items.indexOf(current);
                        if (removedIndex !== -1) {
                            items.splice(removedIndex, 1);

                            remainingItems = remainingItems
                                .map((idx) =>
                                    idx > removedIndex ? idx - 1 : idx
                                )
                                .filter((idx) => idx !== removedIndex);

                            const newViewedItems = new Set();
                            viewedItems.forEach((idx) => {
                                if (idx !== removedIndex) {
                                    const adjustedIndex =
                                        idx > removedIndex ? idx - 1 : idx;
                                    newViewedItems.add(adjustedIndex);
                                }
                            });
                            viewedItems = newViewedItems;

                            history = history
                                .map((idx) =>
                                    idx > removedIndex ? idx - 1 : idx
                                )
                                .filter((idx) => idx !== removedIndex);
                        }

                        if (items.length > 0) {
                            const target = findClosestToCenter() || items[0];
                            target.scrollIntoView({
                                behavior: "auto",
                                block: "start",
                            });

                            current = target;
                            currentIndex = items.indexOf(target);
                            if (currentIndex === -1) {
                                currentIndex = 0;
                                current = items[0];
                            }

                            resetMediaWindow();
                            updateMediaWindow(currentIndex);
                        } else {
                            resetMediaWindow();
                            document.body.innerHTML =
                                '<p style="padding:2rem;color:#aaa">No media files remain.</p>';
                        }
                    } catch (error) {
                        alert("Delete failed: " + error);
                    }
                }

                // Keyboard Controls
                document.addEventListener("keydown", (e) => {
                    if (e.ctrlKey || e.altKey || e.metaKey || e.shiftKey) {
                        return;
                    }

                    const key = e.key.toLowerCase();

                    switch (key) {
                        case "x":
                            e.preventDefault();
                            deleteCurrent();
                            break;
                        case "j":
                            e.preventDefault();
                            navigateToNext();
                            break;
                        case "k":
                            e.preventDefault();
                            navigateToPrevious();
                            break;
                        case "n":
                            e.preventDefault();
                            navigateToRandom();
                            break;
                        case "b":
                            e.preventDefault();
                            navigateBackward();
                            break;
                        case " ":
                            e.preventDefault();
                            toggleCurrentVideo();
                            break;
                        case "h":
                            e.preventDefault();
                            navigateToNextPath();
                            break;
                        case "l":
                            e.preventDefault();
                            navigateToPreviousPath();
                            break;
                        case "u":
                            e.preventDefault();
                            navigateToFirstInPath();
                            break;
                        case "i":
                            e.preventDefault();
                            navigateToLastInPath();
                            break;
                        case "pagedown":
                            e.preventDefault();
                            navigateToNextPath();
                            break;
                        case "pageup":
                            e.preventDefault();
                            navigateToPreviousPath();
                            break;
                        case "home":
                            e.preventDefault();
                            navigateToFirstInPath();
                            break;
                        case "end":
                            e.preventDefault();
                            navigateToLastInPath();
                            break;
                    }
                });
            })();
        </script>
    </body>
</html>
