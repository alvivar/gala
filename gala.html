<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>Gala</title>
        <style>
            * {
                box-sizing: border-box;
            }

            html,
            body {
                height: 100%;
            }

            body {
                margin: 0;
                font-family:
                    system-ui,
                    -apple-system,
                    Segoe UI,
                    Roboto,
                    Helvetica,
                    Arial,
                    sans-serif;
                background: #111;
                color: #eee;
            }

            .grid {
                display: block;
                height: 100vh;
                overflow-y: auto;
                scroll-snap-type: y mandatory;
                padding: 0;
                margin: 0;
            }

            .item {
                height: 100vh;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #000;
                overflow: hidden;
                scroll-snap-align: start;
            }

            .item img,
            .item video {
                display: block;
                max-width: 100vw;
                max-height: 100vh;
                width: auto;
                height: auto;
                object-fit: contain;
                background: #000;
            }

            .item a {
                display: flex;
                width: 100%;
                height: 100%;
                align-items: center;
                justify-content: center;
                color: inherit;
                text-decoration: none;
            }

            .lazy-image,
            .lazy-video {
                background: #000;
            }
        </style>
    </head>
    <body>
        <div class="grid">{items_html}</div>
        <script>
            (function () {
                // Constants
                const LOAD_RADIUS = 2;
                const KEEP_RADIUS = 5;
                const VISIBILITY_RATIO = 0.6;
                const OBSERVER_THRESHOLDS = [0, VISIBILITY_RATIO, 1];

                // State
                let items = Array.from(document.querySelectorAll(".item"));
                let currentItem = items[0] || null;
                let currentIndex = 0;
                let navigationHistory = [];
                let randomPool = createIndexPool(items.length);

                // Media window state
                let keptStart = -1;
                let keptEnd = -1;

                const observer = new IntersectionObserver(handleIntersections, {
                    threshold: OBSERVER_THRESHOLDS,
                });

                items.forEach((item) => observer.observe(item));
                if (items.length > 0) {
                    updateMediaWindow(0);
                }

                // -----------------------------------------------------------------
                // Lazy loading helpers
                // -----------------------------------------------------------------
                function loadImage(img) {
                    if (
                        img.classList.contains("loaded") ||
                        img.classList.contains("loading") ||
                        !img.dataset.src
                    ) {
                        return Promise.resolve();
                    }

                    return new Promise((resolve, reject) => {
                        img.classList.add("loading");

                        const tempImg = new Image();
                        tempImg.onload = () => {
                            img.src = img.dataset.src;
                            img.classList.remove("loading");
                            img.classList.add("loaded");
                            resolve();
                        };

                        tempImg.onerror = () => {
                            img.classList.remove("loading");
                            img.classList.add("error");
                            reject(new Error("Failed to load image"));
                        };

                        tempImg.src = img.dataset.src;
                    });
                }

                function loadVideo(video) {
                    if (
                        video.classList.contains("loaded") ||
                        video.classList.contains("loading") ||
                        !video.dataset.src
                    ) {
                        return Promise.resolve();
                    }

                    return new Promise((resolve, reject) => {
                        video.classList.add("loading");

                        video.onloadeddata = () => {
                            video.classList.remove("loading");
                            video.classList.add("loaded");
                            video.onloadeddata = null;
                            video.onerror = null;
                            resolve();
                        };

                        video.onerror = () => {
                            video.classList.remove("loading");
                            video.classList.add("error");
                            video.onloadeddata = null;
                            video.onerror = null;
                            reject(new Error("Failed to load video"));
                        };

                        video.src = video.dataset.src;
                        video.load();
                    });
                }

                function getMediaElements(item) {
                    return {
                        image: item.querySelector(".lazy-image"),
                        video: item.querySelector(".lazy-video"),
                    };
                }

                function loadMediaAtIndex(index) {
                    if (!isValidIndex(index)) {
                        return;
                    }

                    const { image, video } = getMediaElements(items[index]);

                    if (image && !image.classList.contains("loaded")) {
                        loadImage(image).catch(() => {});
                    }

                    if (video && !video.classList.contains("loaded")) {
                        loadVideo(video).catch(() => {});
                    }
                }

                function unloadMediaAtIndex(index) {
                    if (!isValidIndex(index)) {
                        return;
                    }

                    const { image, video } = getMediaElements(items[index]);

                    if (image && image.src && image.dataset.src) {
                        image.src = "";
                        image.classList.remove("loaded", "loading");
                    }

                    if (video && video.src && video.dataset.src) {
                        video.pause();
                        video.src = "";
                        video.load();
                        video.classList.remove("loaded", "loading");
                    }
                }

                function updateMediaWindow(centerIndex) {
                    if (items.length === 0) {
                        resetMediaWindow();
                        return;
                    }

                    const loadStart = Math.max(0, centerIndex - LOAD_RADIUS);
                    const loadEnd = Math.min(
                        items.length - 1,
                        centerIndex + LOAD_RADIUS,
                    );
                    const keepStart = Math.max(0, centerIndex - KEEP_RADIUS);
                    const keepEnd = Math.min(
                        items.length - 1,
                        centerIndex + KEEP_RADIUS,
                    );

                    for (let i = loadStart; i <= loadEnd; i++) {
                        loadMediaAtIndex(i);
                    }

                    if (keptStart === -1 || keptEnd === -1) {
                        keptStart = keepStart;
                        keptEnd = keepEnd;
                        return;
                    }

                    for (
                        let i = keptStart;
                        i <= Math.min(keepStart - 1, keptEnd);
                        i++
                    ) {
                        unloadMediaAtIndex(i);
                    }

                    for (
                        let i = Math.max(keepEnd + 1, keptStart);
                        i <= keptEnd;
                        i++
                    ) {
                        unloadMediaAtIndex(i);
                    }

                    keptStart = keepStart;
                    keptEnd = keepEnd;
                }

                function resetMediaWindow() {
                    keptStart = -1;
                    keptEnd = -1;
                }

                // -----------------------------------------------------------------
                // Core state helpers
                // -----------------------------------------------------------------
                function isValidIndex(index) {
                    return index >= 0 && index < items.length;
                }

                function createIndexPool(length) {
                    return [...Array(length).keys()];
                }

                function findClosestToCenter() {
                    const centerY = window.innerHeight / 2;
                    let closest = null;
                    let minDistance = Infinity;

                    items.forEach((item) => {
                        const rect = item.getBoundingClientRect();
                        const itemCenterY = rect.top + rect.height / 2;
                        const distance = Math.abs(itemCenterY - centerY);

                        if (distance < minDistance) {
                            minDistance = distance;
                            closest = item;
                        }
                    });

                    return closest;
                }

                function setCurrentByIndex(index) {
                    if (!isValidIndex(index)) {
                        return;
                    }

                    currentIndex = index;
                    currentItem = items[index];
                }

                function getItemPath(item) {
                    if (!item) {
                        return "";
                    }

                    const filename = item.getAttribute("data-filename");
                    if (!filename) {
                        return "";
                    }

                    const slashIndex = filename.lastIndexOf("/");
                    const backslashIndex = filename.lastIndexOf("\\");
                    const separatorIndex = Math.max(slashIndex, backslashIndex);

                    return separatorIndex > -1
                        ? filename.substring(0, separatorIndex)
                        : "";
                }

                function pathAt(index) {
                    return isValidIndex(index) ? getItemPath(items[index]) : "";
                }

                // -----------------------------------------------------------------
                // Observer
                // -----------------------------------------------------------------
                function handleIntersections(entries) {
                    entries.forEach((entry) => {
                        const { video } = getMediaElements(entry.target);
                        const isVisible =
                            entry.isIntersecting &&
                            entry.intersectionRatio > VISIBILITY_RATIO - 0.01;

                        if (isVisible) {
                            const newIndex = items.indexOf(entry.target);
                            if (newIndex !== -1) {
                                if (newIndex !== currentIndex) {
                                    setCurrentByIndex(newIndex);
                                    updateMediaWindow(currentIndex);
                                } else {
                                    currentItem = entry.target;
                                }
                            }

                            if (video && video.classList.contains("loaded")) {
                                video.play().catch(() => {});
                            }
                            return;
                        }

                        if (
                            video &&
                            video.classList.contains("loaded") &&
                            !video.paused
                        ) {
                            video.pause();
                            video.muted = true;
                        }
                    });
                }

                // -----------------------------------------------------------------
                // Navigation
                // -----------------------------------------------------------------
                function navigateToIndex(targetIndex, addToHistory = true) {
                    if (!isValidIndex(targetIndex)) {
                        return;
                    }

                    if (addToHistory && currentIndex !== targetIndex) {
                        navigationHistory.push(currentIndex);
                    }

                    updateMediaWindow(targetIndex);
                    items[targetIndex].scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                    });
                }

                function navigateToNext() {
                    if (items.length === 0) {
                        return;
                    }

                    const nextIndex = (currentIndex + 1) % items.length;
                    navigateToIndex(nextIndex);
                }

                function navigateToPrevious() {
                    if (items.length === 0) {
                        return;
                    }

                    const previousIndex =
                        (currentIndex - 1 + items.length) % items.length;
                    navigateToIndex(previousIndex);
                }

                function navigateToNextPath() {
                    if (items.length === 0) {
                        return;
                    }

                    const currentPath = pathAt(currentIndex);

                    for (let i = currentIndex + 1; i < items.length; i++) {
                        if (pathAt(i) !== currentPath) {
                            navigateToIndex(i);
                            return;
                        }
                    }

                    for (let i = 0; i < currentIndex; i++) {
                        if (pathAt(i) !== currentPath) {
                            navigateToIndex(i);
                            return;
                        }
                    }
                }

                function findPathStart(index) {
                    if (!isValidIndex(index)) {
                        return -1;
                    }

                    const targetPath = pathAt(index);
                    let start = index;
                    while (start > 0 && pathAt(start - 1) === targetPath) {
                        start -= 1;
                    }
                    return start;
                }

                function navigateToPreviousPath() {
                    if (items.length === 0) {
                        return;
                    }

                    const currentPath = pathAt(currentIndex);

                    for (let i = currentIndex - 1; i >= 0; i--) {
                        if (pathAt(i) !== currentPath) {
                            navigateToIndex(findPathStart(i));
                            return;
                        }
                    }

                    for (let i = items.length - 1; i > currentIndex; i--) {
                        if (pathAt(i) !== currentPath) {
                            navigateToIndex(findPathStart(i));
                            return;
                        }
                    }
                }

                function navigateToFirstInPath() {
                    if (items.length === 0) {
                        return;
                    }

                    const currentPath = pathAt(currentIndex);
                    for (let i = 0; i < items.length; i++) {
                        if (pathAt(i) === currentPath) {
                            navigateToIndex(i);
                            return;
                        }
                    }
                }

                function navigateToLastInPath() {
                    if (items.length === 0) {
                        return;
                    }

                    const currentPath = pathAt(currentIndex);
                    for (let i = items.length - 1; i >= 0; i--) {
                        if (pathAt(i) === currentPath) {
                            navigateToIndex(i);
                            return;
                        }
                    }
                }

                function navigateToRandom() {
                    if (items.length === 0) {
                        return;
                    }

                    if (randomPool.length === 0) {
                        randomPool = createIndexPool(items.length);
                    }

                    const currentInPool = randomPool.indexOf(currentIndex);
                    if (currentInPool !== -1) {
                        randomPool.splice(currentInPool, 1);
                    }

                    if (randomPool.length === 0) {
                        return;
                    }

                    const randomIndex = Math.floor(
                        Math.random() * randomPool.length,
                    );
                    const targetIndex = randomPool[randomIndex];
                    navigateToIndex(targetIndex);
                }

                function navigateBackward() {
                    if (navigationHistory.length === 0) {
                        return;
                    }

                    const previousIndex = navigationHistory.pop();
                    navigateToIndex(previousIndex, false);
                }

                function toggleCurrentVideo() {
                    if (!currentItem) {
                        return;
                    }

                    const { video } = getMediaElements(currentItem);
                    if (!video) {
                        return;
                    }

                    if (
                        !video.classList.contains("loaded") &&
                        video.dataset.src
                    ) {
                        loadVideo(video)
                            .then(() => {
                                video.play().catch(() => {});
                            })
                            .catch(() => {});
                        return;
                    }

                    if (video.paused) {
                        video.play().catch(() => {});
                    } else {
                        video.pause();
                    }
                }

                // -----------------------------------------------------------------
                // Deletion
                // -----------------------------------------------------------------
                async function deleteCurrent() {
                    if (!currentItem) {
                        return;
                    }

                    const filename = currentItem.getAttribute("data-filename");
                    if (!filename) {
                        return;
                    }

                    try {
                        const response = await fetch(
                            "/api/delete?name=" + encodeURIComponent(filename),
                            { method: "DELETE" },
                        );

                        const data = await response.json().catch(() => ({}));
                        if (!response.ok || !data.ok) {
                            const errorMessage = data.error
                                ? ": " + data.error
                                : "";
                            alert("Delete failed" + errorMessage);
                            return;
                        }

                        const { video } = getMediaElements(currentItem);
                        if (video) {
                            try {
                                video.pause();
                                video.src = "";
                            } catch (e) {}
                        }

                        const removedItem = currentItem;
                        observer.unobserve(removedItem);

                        const removedIndex = items.indexOf(removedItem);
                        removedItem.remove();

                        if (removedIndex !== -1) {
                            items.splice(removedIndex, 1);

                            randomPool = randomPool
                                .map((idx) =>
                                    idx > removedIndex ? idx - 1 : idx,
                                )
                                .filter((idx) => idx !== removedIndex);

                            navigationHistory = navigationHistory
                                .map((idx) =>
                                    idx > removedIndex ? idx - 1 : idx,
                                )
                                .filter((idx) => idx !== removedIndex);
                        }

                        if (items.length === 0) {
                            resetMediaWindow();
                            currentItem = null;
                            currentIndex = 0;
                            document.body.innerHTML =
                                '<p style="padding:2rem;color:#aaa">No media files remain.</p>';
                            return;
                        }

                        const targetItem = findClosestToCenter() || items[0];
                        targetItem.scrollIntoView({
                            behavior: "auto",
                            block: "start",
                        });

                        const targetIndex = items.indexOf(targetItem);
                        setCurrentByIndex(targetIndex === -1 ? 0 : targetIndex);

                        resetMediaWindow();
                        updateMediaWindow(currentIndex);
                    } catch (error) {
                        alert("Delete failed: " + error);
                    }
                }

                // -----------------------------------------------------------------
                // Keyboard controls
                // -----------------------------------------------------------------
                document.addEventListener("keydown", (event) => {
                    if (
                        event.ctrlKey ||
                        event.altKey ||
                        event.metaKey ||
                        event.shiftKey
                    ) {
                        return;
                    }

                    const key = event.key.toLowerCase();

                    switch (key) {
                        case "x":
                            event.preventDefault();
                            deleteCurrent();
                            break;
                        case "j":
                            event.preventDefault();
                            navigateToNext();
                            break;
                        case "k":
                            event.preventDefault();
                            navigateToPrevious();
                            break;
                        case "n":
                            event.preventDefault();
                            navigateToRandom();
                            break;
                        case "b":
                            event.preventDefault();
                            navigateBackward();
                            break;
                        case " ":
                            event.preventDefault();
                            toggleCurrentVideo();
                            break;
                        case "h":
                        case "pagedown":
                            event.preventDefault();
                            navigateToNextPath();
                            break;
                        case "l":
                        case "pageup":
                            event.preventDefault();
                            navigateToPreviousPath();
                            break;
                        case "u":
                        case "home":
                            event.preventDefault();
                            navigateToFirstInPath();
                            break;
                        case "i":
                        case "end":
                            event.preventDefault();
                            navigateToLastInPath();
                            break;
                    }
                });
            })();
        </script>
    </body>
</html>
