<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>Gala</title>
        <style>
            * {
                box-sizing: border-box;
            }
            html,
            body {
                height: 100%;
            }
            body {
                margin: 0;
                font-family: system-ui, -apple-system, Segoe UI, Roboto,
                    Helvetica, Arial, sans-serif;
                background: #111;
                color: #eee;
            }
            .grid {
                display: block;
                height: 100vh;
                overflow-y: auto;
                scroll-snap-type: y mandatory;
                padding: 0;
                margin: 0;
            }
            .item {
                height: 100vh;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #000;
                overflow: hidden;
                scroll-snap-align: start;
            }
            .item img,
            .item video {
                display: block;
                max-width: 100vw;
                max-height: 100vh;
                width: auto;
                height: auto;
                object-fit: contain;
                background: #000;
            }
            .item a {
                display: flex;
                width: 100%;
                height: 100%;
                align-items: center;
                justify-content: center;
                color: inherit;
                text-decoration: none;
            }
        </style>
    </head>
    <body>
        <div class="grid">{items_html}</div>
        <script>
            (function () {
                // State Management

                let items = Array.from(document.querySelectorAll(".item"));
                let current = items[0] || null;
                let currentIndex = 0;
                let history = [];
                let remainingItems = [...Array(items.length).keys()];
                let viewedItems = new Set();

                // Intersection Observer

                const observer = new IntersectionObserver(
                    (entries) => {
                        entries.forEach((entry) => {
                            const video = entry.target.querySelector("video");

                            if (
                                entry.isIntersecting &&
                                entry.intersectionRatio > 0.6 - 0.01
                            ) {
                                current = entry.target;
                                currentIndex = items.indexOf(entry.target);

                                if (video) {
                                    video.play();
                                }
                            } else {
                                if (video && !video.paused) {
                                    video.pause();
                                    video.muted = true;
                                }
                            }
                        });
                    },
                    { threshold: [0, 0.6, 1] }
                );

                items.forEach((item, index) => {
                    observer.observe(item);
                });

                // Utility Functions

                function findClosestToCenter() {
                    const center = innerHeight / 2;
                    let closest = null;
                    let minDistance = Infinity;

                    items.forEach((item, index) => {
                        const rect = item.getBoundingClientRect();
                        const itemCenter = rect.top + rect.height / 2;
                        const distance = Math.abs(itemCenter - center);

                        if (distance < minDistance) {
                            minDistance = distance;
                            closest = item;
                        }
                    });

                    return closest;
                }

                function navigateToIndex(targetIndex, addToHistory = true) {
                    if (addToHistory && currentIndex !== targetIndex) {
                        history.push(currentIndex);
                    }

                    items[targetIndex].scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                    });
                }

                // Video Controls

                function toggleCurrentVideo() {
                    if (!current) {
                        return;
                    }

                    const video = current.querySelector("video");
                    if (!video) {
                        return;
                    }

                    if (video.paused) {
                        video.play();
                    } else {
                        video.pause();
                    }
                }

                // Navigation Functions

                function navigateToNext() {
                    if (items.length === 0) {
                        return;
                    }

                    const nextIndex = (currentIndex + 1) % items.length;
                    navigateToIndex(nextIndex);
                }

                function navigateToPrevious() {
                    if (items.length === 0) {
                        return;
                    }

                    const prevIndex =
                        (currentIndex - 1 + items.length) % items.length;
                    navigateToIndex(prevIndex);
                }

                function navigateToRandom() {
                    if (items.length === 0) {
                        return;
                    }

                    if (remainingItems.length === 0) {
                        remainingItems = [...Array(items.length).keys()];
                        viewedItems.clear();
                    }

                    viewedItems.add(currentIndex);

                    const currentInRemaining =
                        remainingItems.indexOf(currentIndex);
                    if (currentInRemaining !== -1) {
                        remainingItems.splice(currentInRemaining, 1);
                    }

                    if (remainingItems.length > 0) {
                        const randomIndex = Math.floor(
                            Math.random() * remainingItems.length
                        );
                        const targetIndex = remainingItems[randomIndex];

                        navigateToIndex(targetIndex);
                    }
                }

                function navigateBackward() {
                    if (history.length === 0) {
                        return;
                    }

                    const previousIndex = history.pop();
                    navigateToIndex(previousIndex, false);
                }

                // Deletion Functionality

                async function deleteCurrent() {
                    if (!current) {
                        return;
                    }

                    const filename = current.getAttribute("data-filename");
                    if (!filename) {
                        return;
                    }

                    try {
                        const response = await fetch(
                            "/api/delete?name=" + encodeURIComponent(filename),
                            {
                                method: "DELETE",
                            }
                        );

                        const data = await response.json().catch(() => ({}));

                        if (!response.ok || !data.ok) {
                            const errorMessage = data.error
                                ? ": " + data.error
                                : "";
                            alert("Delete failed" + errorMessage);
                            return;
                        }

                        const video = current.querySelector("video");
                        if (video) {
                            try {
                                video.pause();
                                video.src = "";
                            } catch (e) {}
                        }

                        observer.unobserve(current);
                        current.remove();

                        const removedIndex = items.indexOf(current);

                        if (removedIndex !== -1) {
                            items.splice(removedIndex, 1);

                            remainingItems = remainingItems
                                .map((idx) =>
                                    idx > removedIndex ? idx - 1 : idx
                                )
                                .filter((idx) => idx !== removedIndex);

                            const newViewedItems = new Set();
                            viewedItems.forEach((idx) => {
                                if (idx !== removedIndex) {
                                    const adjustedIndex =
                                        idx > removedIndex ? idx - 1 : idx;
                                    newViewedItems.add(adjustedIndex);
                                }
                            });
                            viewedItems = newViewedItems;

                            history = history
                                .map((idx) =>
                                    idx > removedIndex ? idx - 1 : idx
                                )
                                .filter((idx) => idx !== removedIndex);
                        }

                        if (items.length > 0) {
                            const target = findClosestToCenter();
                            if (target) {
                                target.scrollIntoView({
                                    behavior: "instant",
                                    block: "start",
                                });

                                current = target;
                                currentIndex = items.indexOf(target);
                            }
                        } else {
                            document.body.innerHTML =
                                '<p style="padding:2rem;color:#aaa">No media files remain.</p>';
                        }
                    } catch (error) {
                        alert("Delete failed: " + error);
                    }
                }

                // Keyboard Controls

                document.addEventListener("keydown", (e) => {
                    const key = e.key.toLowerCase();

                    switch (key) {
                        case "x":
                            e.preventDefault();
                            deleteCurrent();
                            break;
                        case "j":
                            e.preventDefault();
                            navigateToNext();
                            break;
                        case "k":
                            e.preventDefault();
                            navigateToPrevious();
                            break;
                        case "n":
                            e.preventDefault();
                            navigateToRandom();
                            break;
                        case "b":
                            e.preventDefault();
                            navigateBackward();
                            break;
                        case " ":
                            e.preventDefault();
                            toggleCurrentVideo();
                            break;
                    }
                });
            })();
        </script>
    </body>
</html>
